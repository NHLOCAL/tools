<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>מחולל פודקאסטים AI</title>
  <style>
    /* Material Design 3 & Fluent-inspired styling */
    :root { --surface: #F3F2F1; --on-surface: #323130; --primary: #6750A4; --primary-container: #EADDFF; --on-primary-container: #21005D; --secondary: #625B71; --secondary-container: #E8DEF8; --on-secondary-container: #1D192B; --radius: 16px; --padding: 16px; --shadow: 0 4px 16px rgba(0,0,0,0.1); font-family: 'Segoe UI', Roboto, sans-serif; }
    * { box-sizing: border-box; }
    body { margin: 0; padding: var(--padding); background: var(--surface); color: var(--on-surface); }
    .card { background: white; border-radius: var(--radius); box-shadow: var(--shadow); padding: var(--padding); margin-bottom: var(--padding); }
    h1 { margin-top: 0; font-size: 1.5rem; }
    label { display: block; margin-bottom: 8px; font-weight: 500; }
    input, textarea, select, button { width: 100%; padding: 12px; margin-bottom: 12px; border: none; border-radius: calc(var(--radius)/2); background: var(--primary-container); color: var(--on-primary-container); font-size: 1rem; }
    input:focus, textarea:focus, select:focus { outline: 2px solid var(--primary); }
    button { cursor: pointer; background: var(--primary); color: white; font-weight: 600; transition: background 0.3s; }
    button:hover { background: var(--on-primary-container); }
    button:disabled {
      background: #d1cfe2;
      color: #888;
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none;
      border: 1px solid #ccc;
    }
    details { background: var(--secondary-container); border-radius: var(--radius); padding: var(--padding); margin-bottom: var(--padding); }
    summary { font-weight: 600; cursor: pointer; }
    audio { width: 100%; margin-top: 8px; }
    #status { font-size: 0.9rem; color: var(--secondary); }
    a#downloadLink {
      display: inline-block;
      margin-top: 12px;
      padding: 12px 24px;
      background: var(--primary);
      color: #fff;
      border-radius: calc(var(--radius)/2);
      text-decoration: none;
      font-weight: 600;
      font-size: 1rem;
      box-shadow: var(--shadow);
      transition: background 0.3s, color 0.3s, box-shadow 0.3s;
      cursor: pointer;
    }
    a#downloadLink:hover, a#downloadLink:focus {
      background: var(--on-primary-container);
      color: #fff;
      box-shadow: 0 2px 8px rgba(103,80,164,0.15);
      outline: none;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>מחולל פודקאסטים AI</h1>
    <label for="apiKeyInput">מפתח API (או הגדר משתנה סביבה GEMINI_API_KEY בדפדפן)</label>
    <input id="apiKeyInput" type="password" placeholder="הכנס מפתח או השאר ריק אם הוגדר משתנה סביבה" />
    
    <label for="topicInput">נושא הפודקאסט</label>
    <input id="topicInput" type="text" placeholder="הכנס את הנושא שלך" />

    <label for="durationInput">אורך רצוי (דקות)</label>
    <input id="durationInput" type="number" value="7" min="1" max="20" />

    <label for="speakersConfig">תצורת דוברים</label>
    <select id="speakersConfig">
      <option value="male_female" selected>גבר ואישה</option>
      <option value="two_males">שני גברים</option>
      <option value="two_females">שתי נשים</option>
    </select>
    
    <button id="genScriptBtn">צור תסריט</button>
    <div id="status"></div>
  </div>

  <details id="scriptPanel">
    <summary>תסריט הפודקאסט</summary>
    <textarea id="scriptArea" rows="15"></textarea>
  </details>

  <div class="card">
    <button id="genAudioBtn">צור שמע (WAV)</button>
    <audio id="audioPlayer" controls></audio>
    <a id="downloadLink" download="podcast.wav" style="pointer-events: none; opacity: 0.5;">הורד קובץ WAV</a>
  </div>

  <script>
    function getApiKey() {
      // 1. מהשדה הידני
      const manualKey = document.getElementById('apiKeyInput').value.trim();
      if (manualKey) return manualKey;
      // 2. window (אם הוזרק ע"י סקריפט)
      if (window.GEMINI_API_KEY && typeof window.GEMINI_API_KEY === 'string' && window.GEMINI_API_KEY.length > 0) {
        return window.GEMINI_API_KEY;
      }
      // 3. localStorage (אם נשמר שם)
      if (localStorage.getItem('GEMINI_API_KEY')) {
        return localStorage.getItem('GEMINI_API_KEY');
      }
      // 4. שדה חבוי (אם הוספת כזה)
      const envInput = document.getElementById('envApiKey');
      if (envInput && envInput.value) {
        return envInput.value;
      }
      return '';
    }

    // שמירת מפתח ל-localStorage אוטומטית אם הוזן ידנית
    document.getElementById('apiKeyInput').addEventListener('change', function(e) {
      if (e.target.value.trim()) {
        localStorage.setItem('GEMINI_API_KEY', e.target.value.trim());
      }
    });

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    DataView.prototype.setString = function(offset, str) {
        for (let i = 0; i < str.length; i++) {
            this.setUint8(offset + i, str.charCodeAt(i));
        }
    };

    function buildSystemPrompt(duration, speakersConfig) {
      const baseIntro = `You are an AI specializing in writing podcast scripts. Your task is to create a dialogue that feels like a lively, engaging, and humorous **intellectual sparring match**. The conversation must be dynamic, fast-paced, and above all, thought-provoking.

The desired podcast length is approximately ${duration} minutes.

#### **General Conversation Style:**
The guiding style is one of **sharp and amused cynicism**. The speakers don't aim to belittle or dismiss; they use biting wit as a tool to expose absurdities, deconstruct conventions, and examine ideas from unexpected angles. The dialogue should be intelligent yet accessible; critical, yet driven by genuine curiosity. The goal is to make the listener smile, but more importantly, to make them think.`;

      const outputStructureTemplate = `
#### **Exact Output Structure:**

1.  **English Directive:**
    *   The output must begin **directly** with an English directive for a Text-to-Speech (TTS) model.
    *   This directive will describe **only** the required manner of speaking (tone, pace, style). **Do not mention the episode's topic.**
    *   The speaking styles for the speakers must be **different and adapted for each new script.**
    *   **Crucially:** The directive must be written as a **single, continuous sentence** describing the dynamic between the speakers (e.g., "[EXAMPLE_DIRECTIVE]"). It should **not** be broken down into a list format with separate instructions for each speaker.
    *   The directive should state that short vocal cues in parentheses, like (צוחק) or (אנחה), should be incorporated and used **sparingly**.
    *   The cues will be in Hebrew, without Nikkud, and include **only simple, audible actions** (no facial expressions or gestures).
    *   The English directive **must not** end with a colon (:).

2.  **Hebrew Dialogue:**
    *   Immediately following the English directive, the dialogue will appear.
    *   Speaker names will appear in English: [SPEAKER_TAGS].
    *   **Ensure grammatically correct gender agreement throughout the dialogue** (masculine/feminine forms) to maintain natural and fluent Hebrew.
    *   The entire text will be in **Hebrew, without Nikkud (vocalization).**`;
      
      let characterProfiles = '';
      let speakerTags = '';
      let exampleDirective = '';

      switch (speakersConfig) {
        case 'two_males':
          characterProfiles = `
#### **Character Profiles:**
Their interaction is the heart of the podcast. They complement and challenge each other.

*   **speaker1:** He possesses a **captivating intellectual presence and a lively, fascinating speaking style**. He uses sharp cynicism and provocative arguments to deconstruct ideas, captivating the listener.
*   **speaker2:** He is a natural storyteller with a calm, resonant voice. He often grounds the abstract arguments of speaker1 with historical anecdotes, real-world examples, and a touch of philosophical melancholy.`;
          speakerTags = '`speaker1:`, `speaker2:`';
          exampleDirective = 'speaker1 should adopt a thoughtfully provocative tone, while speaker2 counters with calm, story-driven insights';
          break;

        case 'two_females':
          characterProfiles = `
#### **Character Profiles:**
Their interaction is the heart of the podcast. They complement and challenge each other.

*   **speaker1:** She possesses a **quicker, more energetic wit**. She acts as a pragmatic foil, bringing discussions back to the human element with playful irony.
*   **speaker2:** She has a more deliberate, thoughtful delivery. She enjoys exploring the philosophical and societal implications of the topic, expanding the conversation with 'what if' scenarios and dry humor.`;
          speakerTags = '`speaker1:`, `speaker2:`';
          exampleDirective = 'speaker1 should adopt a rapid-fire, incisive style, while speaker2 responds with thoughtful, philosophical expansions';
          break;

        case 'male_female':
        default:
          characterProfiles = `
#### **Character Profiles:**
Their interaction is the heart of the podcast. They complement and challenge each other.

*   **man:** He possesses a **captivating intellectual presence and a lively, fascinating speaking style**. His approach is analytical, but he presents it with engaging energy and personal charm. He uses sharp cynicism and provocative arguments to deconstruct ideas.
*   **girl:** She possesses a **quicker, more energetic wit**. She often acts as a pragmatic foil to his statements, bringing the discussion back down to earth with playful irony.`;
          speakerTags = '`man:`, `girl:`';
          exampleDirective = 'man should adopt a thoughtfully provocative tone, while girl counters with rapid-fire, incisive questions';
          break;
      }

      const outputStructure = outputStructureTemplate
        .replace('[SPEAKER_TAGS]', speakerTags)
        .replace('[EXAMPLE_DIRECTIVE]', exampleDirective);

      return `${baseIntro}\n${characterProfiles}\n${outputStructure}`;
    }


    async function generateScript() {
      updateStatus('יוצר תסריט...');
      const genScriptBtn = document.getElementById('genScriptBtn');
      genScriptBtn.disabled = true;

      const topic = document.getElementById('topicInput').value.trim();
      const duration = document.getElementById('durationInput').value;
      const speakersConfig = document.getElementById('speakersConfig').value;

      if (!topic) {
        alert('יש להזין נושא.');
        updateStatus('');
        return;
      }
      const key = getApiKey();
      if (!key) {
        alert('מפתח API חסר. יש להזין אותו בשדה המיועד או להגדיר את המשתנה window.GEMINI_API_KEY בדפדפן.');
        updateStatus('');
        return;
      }
      
      const systemPrompt = buildSystemPrompt(duration, speakersConfig);

      const model = 'gemini-2.5-flash';
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

      const body = {
        systemInstruction: { parts: [{ text: systemPrompt }] },
        contents: [{ parts: [{ text: `Topic: ${topic}` }] }]
      };

      try {
        const res = await fetch(`${url}?key=${encodeURIComponent(key)}`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(`שגיאת API: ${errorData.error.message}`);
        }
        const data = await res.json();
        const script = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        document.getElementById('scriptArea').value = script;
        document.getElementById('scriptPanel').open = true;
        updateStatus('התסריט מוכן');
      } catch (error) {
        updateStatus(`שגיאה ביצירת התסריט: ${error.message}`);
        console.error(error);
      } finally {
        genScriptBtn.disabled = false;
      }
    }

    function createWavBlob(pcmData) {
        const numChannels = 1;
        const sampleRate = 24000;
        const bitsPerSample = 16;
        const dataSize = pcmData.length;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        view.setString(0, 'RIFF');
        view.setUint32(4, 36 + dataSize, true);
        view.setString(8, 'WAVE');
        view.setString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
        view.setUint16(32, numChannels * (bitsPerSample / 8), true);
        view.setUint16(34, bitsPerSample, true);
        view.setString(36, 'data');
        view.setUint32(40, dataSize, true);
        new Uint8Array(buffer, 44).set(pcmData);

        return new Blob([buffer], { type: 'audio/wav' });
    }

    function setDownloadLinkEnabled(enabled) {
      const link = document.getElementById('downloadLink');
      if (enabled) {
        link.style.pointerEvents = '';
        link.style.opacity = '';
        link.setAttribute('aria-disabled', 'false');
        link.tabIndex = 0;
      } else {
        link.style.pointerEvents = 'none';
        link.style.opacity = '0.5';
        link.setAttribute('aria-disabled', 'true');
        link.tabIndex = -1;
        link.removeAttribute('href');
      }
    }
    setDownloadLinkEnabled(false);

    async function generateAudio() {
      updateStatus('יוצר שמע...');
      const genAudioBtn = document.getElementById('genAudioBtn');
      genAudioBtn.disabled = true;
      setDownloadLinkEnabled(false);

      const script = document.getElementById('scriptArea').value.trim();
      if (!script) {
        alert('התסריט ריק');
        updateStatus('');
        return;
      }
      const key = getApiKey();
      if (!key) {
        alert('מפתח API חסר');
        updateStatus('');
        return;
      }
      
      const speakersConfigChoice = document.getElementById('speakersConfig').value;
      let speechConfig;
      
      // *** START OF UPDATED CODE BLOCK ***
      // This block now builds the speechConfig object according to the new documentation.
      // The main object is 'multiSpeakerVoiceConfig' containing an array 'speakerVoiceConfigs'.
      switch (speakersConfigChoice) {
        case 'two_males':
          speechConfig = {
            multiSpeakerVoiceConfig: {
              speakerVoiceConfigs: [
                {
                  speaker: "speaker1",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Sadaltager" } }
                },
                {
                  speaker: "speaker2",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Alnilam" } }
                }
              ]
            }
          };
          break;
        case 'two_females':
          speechConfig = {
            multiSpeakerVoiceConfig: {
              speakerVoiceConfigs: [
                {
                  speaker: "speaker1",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } }
                },
                {
                  speaker: "speaker2",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Aoede" } }
                }
              ]
            }
          };
          break;
        case 'male_female':
        default:
          speechConfig = {
            multiSpeakerVoiceConfig: {
              speakerVoiceConfigs: [
                {
                  speaker: "man",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Sadaltager" } }
                },
                {
                  speaker: "girl",
                  voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } }
                }
              ]
            }
          };
          break;
      }
      // *** END OF UPDATED CODE BLOCK ***
      
      const model = 'gemini-2.5-flash-preview-tts'; 
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

      const body = {
        "contents": [{
          "parts": [{ "text": script }] 
        }],
        "generationConfig": {
          "responseModalities": ["AUDIO"],
          // The correctly structured speechConfig object is placed here
          "speechConfig": speechConfig
        }
      };

      try {
        const res = await fetch(`${url}?key=${encodeURIComponent(key)}`, {
            method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(body)
        });
        if (!res.ok) {
            const errorData = await res.json();
            const details = errorData.error?.message || 'לא התקבל פירוט';
            throw new Error(`שגיאת API: ${details}`);
        }
        const data = await res.json();
        
        const audioPart = data.candidates?.[0]?.content?.parts?.find(p => p.inlineData);

        if (!audioPart) {
            const textResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || "לא התקבל מידע שמע מה-API.";
            throw new Error(`ה-API לא החזיר אודיו. ייתכן שהתסריט אינו תקין. תגובת המודל: ${textResponse}`);
        }

        const b64 = audioPart.inlineData.data;
        const pcmBytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const wavBlob = createWavBlob(pcmBytes);
        const urlObj = URL.createObjectURL(wavBlob);

        const player = document.getElementById('audioPlayer');
        player.src = urlObj;
        player.play();
        document.getElementById('downloadLink').href = urlObj;
        setDownloadLinkEnabled(true);
        updateStatus('השמע מוכן');
      } catch(error) {
        setDownloadLinkEnabled(false);
        updateStatus(`שגיאה ביצירת השמע: ${error.message}`);
        console.error(error);
      } finally {
        genAudioBtn.disabled = false;
      }
    }

    document.getElementById('genScriptBtn').onclick = generateScript;
    document.getElementById('genAudioBtn').onclick = generateAudio;
  </script>
</body>
</html>